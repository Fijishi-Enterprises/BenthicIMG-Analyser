# This conf file was generated by a Django management command.

# http directives go at the top level here.

# Don't display nginx version in nginx's generic error pages.
server_tokens off;

# Increase this if nginx startup errors with "could not build
# server_names_hash, you should increase server_names_hash_bucket_size".
# Apparently this should be a power of 2.
# http://nginx.org/en/docs/http/server_names.html
server_names_hash_bucket_size 128;

server {
    # Only answer requests that have one of these host header values.
    # This prevents host header spoofing attacks.
    server_name {{ nginx_allowed_hosts }};

    # Static file requests: Serve this URL pattern using this directory.
    location /static {
        alias /srv/www/static_serve;
    }

    # Other requests: Handle with gunicorn.
    location / {
        # gunicorn is assumed to be bound to this host and port.
        # As a result of this proxy pass,
        # the working value of Django's ALLOWED_HOSTS is 127.0.0.1.
        proxy_pass http://127.0.0.1:8001;
        
        # Request timeout.
        # Note that gunicorn also has a timeout period. The lower of the
        # gunicorn/nginx timeouts is the effective timeout period.
        proxy_read_timeout 604800s;
        
        # Upload size limit.
        # This is just a failsafe in case our Django app doesn't specify a
        # size limit in every possible upload case.
        #
        # Our Django app can display a helpful error message, and nginx can't.
        # So, set this strictly higher than every upload filesize limit
        # specified in the Django settings.
        client_max_body_size 40m;
    }
}

server {
    # "default_server" explicitly indicates that this services any requests
    # that don't match the other server blocks' port/server_name.
    #
    # TODO: See if this needs to be extended beyond port 80 when we have HTTPS.
    listen 80 default_server;

    # Respond with an nginx "No response" code.
    return 444;
}
